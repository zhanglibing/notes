---
layout: post
title:  "vue面试总结"
tags:
categories:
---

### mvvm框架是什么
vue数据驱动，通过数据来显示视图层而不是节点操作

### Vue的双向数据绑定原理是什么(vue data是怎么实现的)？
vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：

- 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

- 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

- 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

- 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

### vue生命周期的理解
创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。

载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

更新前/后：当data变化时，会触发beforeUpdate和updated方法。

销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
           解除事件绑定、清除定时函数等
           
### vue-loader是什么？使用它的用途有哪些
   答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。
   用途：js可以写es6、style样式可以scss或less、template可以加jade等
 
### 插槽，具名插槽，插槽默认内容   
单个插槽；在父组件写一个标签，在子组件通过slot来接受标签里的内容,他只能用一个slot。
单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。
具名插槽：在父组件标签写入slot，子组件里面写name名字，他们两个名字要相对应，才能通过名字在找到对应的位置。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。

### 作用域插槽
举个例子，比如我写了一个可以实现条纹相间的列表组件，发布后，使用者可以自定义每一行的内容或样式（普通的slot就可以完成这个工作）。而作用域插槽的关键之处就在于，父组件能接收来自子组件的slot传递过来的参数，
子组件与父组件的数据动态交互的一种常见案例父组件中必须要有template元素，且必须有scope特性，scope特性中是临时变量名， 接收从子组件中传递上来的属性，属性可以是任意定义的。

###  vuex中使用persistedstate 插件进行长久储存
- npm install `vuex-persistedstate` --save

```javascript

store.js引入import VuexPersistence from "vuex-persist";
//创建一个对象：
const vuexLocal = new VuexPersistence({ storage:window.localStorage})
//安装进vuex插件：
export default new Vuex.Store({ 
   state:{      
       info:{}  
     },    
     mutations:{ 
           setInfo(state,info){    
                 state.info=info;   
             }   
    },   
    plugins:[VuexPersistence()]})
    //默认存储到localStorage
          
    // 想要存储到sessionStorage，配置如下
    import createPersistedState from "vuex-persistedstate"
    const store = new Vuex.Store({
        plugins: [createPersistedState({storage: window.sessionStorage })]
    })



```

### vue多页应用
 - https://www.cnblogs.com/xiyangcai/p/8609773.html
 
 ### vuex
 - state，action，mutation，getter，module
 State：数据源存放地，数据是响应式的
 Action: 逻辑处理，提交的是mutation,包含任意异步操作
 Mutation: 修改state里的公共数据
 Getter: 相当于计算属性，可以复用，可缓存
 Module: 模块化
 
- Vuex取值
 This.$store.state.city
 This.$store.commit(‘getData’)
 this.$store.dispath(‘getData’)
 This.$store.getters.getData
 
### beforeRouteEnter(to,from,next){next(vm=>{ vm相当于this})} 路由跳转时
### 为什么使用key？
当有相同标签名和元素切换时，需要通过key特性设置唯一的值来标记让vue区分它们，
否则vue为了效率只会替换相同标签内部的内容

### 为什么避免v-if和v-for用在一起？
当vue处理指令时，v-for比v-if具有更高的优先级，通过v-if移动到容器的元素，不会在重复遍历列表中的每个值，
取而代之的是，我们只检查它一次，且不会v-if为否的时候运算v-for

### vue和react区别
- 相同点：
  - 都鼓励组件化，都有’props’的概念，都有自己的构建工具，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。
- 不同点：
  - React：数据流单向，语法—JSX，在React中你需要使用setState()方法去更新状态
  - Vue：数据双向绑定，语法--HTML，state对象并不是必须的，数据由data属性在Vue对象中进行管理。适用于小型应用，但对于对于大型应用而言不太适合。
  
### 单页面和多页面的区别
 - 单页面：
 
 整个项目中只有一个完整的HTML页面，其它"页面"只是一段HTML片断而已
 
 优: 请求少
 
 缺: 不利于搜索引擎优化
 
 页面跳转本质：把当前DOM树中某个DIV删除，下载并挂载另一个div片断
 
 - 多页面：
 
 项目中有多个独立的完整的HTML页面
 
 缺: 请求次数多，效率低
 
 页面跳转本质:
 
 删除旧的DOM树，重新下载新的DOM树 
 
 
 ### js中new一个对象的过程
- 1、创建一个新对象：
　　var obj = {};
- 2、设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；
　　`obj.__proto__ = ClassA.prototype`;
- 3、使用新对象调用函数，函数中的this被指向新实例对象：
　　ClassA.call(obj);　　//{}.构造函数()
- 4、将初始化完毕的新对象地址，保存到等号左边的变量中

### undefined 和 null 区别
- null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。
- undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。

### http 和 https 有何区别？如何灵活使用？
- http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。

- https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份

### 什么是mvvm mvc是什么区别 原理
- MVC（Model-View-Controller）
MVC是比较直观的架构模式，用户操作->View（负责接收用户的输入操作）->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）。
MVC使用非常广泛，比如JavaEE中的SSH框架
- MVVM（Model-View-ViewModel）
如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，
而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应view。

### JS哪些操作会造成内存泄露
- 意外的全局变量引起的内存泄露;
`function leak(){  
  leak="xxx";//leak成为一个全局变量，不会被回收  
}`
- 2）闭包引起的内存泄露
- 3）3）没有清理的DOM元素引用
- 4）被遗忘的定时器或者回调 5）子元素存在引起的内存泄露

### 怎样添加、移除、移动、复制、创建和查找节点
```javascript
//1）创建新节点

createDocumentFragment() //创建一个DOM片段
createElement() //创建一个具体的元素
createTextNode() //创建一个文本节点

//2）添加、移除、替换、插入
appendChild() //添加
removeChild() //移除
replaceChild() //替换
insertBefore() //插入

//3）查找
getElementsByTagName() //通过标签名称
getElementsByName() //通过元素的Name属性的值
getElementById() //通过元素Id，唯一性

```
 
### 从输入url到显示页面，都经历了什么
- 第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器。

- 第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回。

- 第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址。
- 第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址。
- 第五步：重复第四步,直到找到正确的纪录。

- 第2种解释：
    一般会经历以下几个过程：
    - 1、首先，在浏览器地址栏中输入url
    - 2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
    - 3、在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。
    - 4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）
    - 5、握手成功后，浏览器向服务器发送http请求，请求数据包。
    - 6、服务器处理收到的请求，将数据返回至浏览器
    - 7、浏览器收到HTTP响应
    - 8、读取页面内容，浏览器渲染，解析html源码
    - 9、生成Dom树、解析css样式、js交互
    - 10、客户端和服务器交互
    - 11、ajax查询

### display none visibility hidden区别？
1.display:none是彻底消失，不在文档流中占位，浏览器也不会解析该元素；visibility:hidden是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；
2.使用visibility:hidden比display:none性能上要好，display:none切换显示时visibility，页面产生回流（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流），而visibility切换是否显示时则不会引起回流。

### 谈谈垃圾回收机制方式及内存管理

### `$(document).ready()`方法和`window.onload`有什么区别？
- `window.onload`方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。
- `$(document).ready()` 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。