---
layout: post
title:  "React"
tags:
categories:
---
### React特点
- 虚拟DOM: 
  React也是以数据驱动的，每次数据变化React都会扫码整个虚拟DOM树，自动计算与上次虚拟DOM的差异变化，然后针对需要变化的部分进行实际的浏览器DOM更新。
- 组件化：
  React可以从功能角度横向划分，将UI分解成不同组件，各组件都独立封装，整个UI是由一个个小组件构成的一个大组件，每个组件只关系自身的逻辑，彼此独立。
- 单项数据流：
  React设计者认为数据双向绑定虽然便捷，但在复杂场景下副作用也是很明显，所以React更倾向于单向的数据流动-从父节点传递到子节点。（使用ReactLink也可以实现双向绑定，但不建议使用）
  
### state 状态
- 只能在组件的constructor中初始化
- 只能 用setState方法更新
- setState会导致render重新执行，渲染组件和子组件

```javascript
constructor(props){
    super(props); //继承父类的props
    //方法1
    this.state={ //初始化
       val:1
    }
}
 //方法2
//初始化赋值
getInitialState:function(){
  return {
        userName: "zhanglibing",
        age: 26
  }; 
}
```
### 生命周期图
 ![Image-text](https://raw.githubusercontent.com/zhanglibing/notes/master/image/react/life.png)

```javascript

//有参数的生命周期
componentWillReceiveProps(nextProps){}
shouldComponentUpdate(nextProps,nextState){
    return true;
}
componentWillUpdate(nextProps,nextState){}
componentDidUpdate(nextProps,nextState){}
```

### defaultProps 设置默认参数  类型检查propTypes

```javascript

import PropTypes from 'prop-types'
class Title extends Component{
    //方法1
    static defaultProps={  //类的静态属性 （最新方法）
        title:'默认值'
    }
    //方法2
    getDefaultProps(){  //设置默认值
         return {
            title:'zhanglibing'
         }
    }
    
    //类型检查propTypes
    static proTypes ={
        themeColor:PropTypes.string
    }
    
}
//方法3
Title.defaultProps={ //旧版（es6语法)
    title:'默认值'
}
```

### context 上下文

```javascript
import PropTypes from 'prop-types'
class Parent extends Component{
    constructor(props){
        super(props);
        this.state={
            color:"#000"
        }
    }
    //静态属性的类型检查
    static childContextTypes ={
            themeColor:PropTypes.string,
            changeColor:PropTypes.func
        }
    changeColor(coloe){
        this.setState({
          color:color
        })
    }
    
    //设置给子组件传递的值
    getChildContext(){
        themeColor:this.state.color,
        changeColor:(color)=>childContextTypes(color)
        
    }
}

class Child extends Component{
    static contextTypes ={
        themeColor:PropTypes.string,
        changeColor:PropTypes.func
    }
    render(){
        let {themeColor,changeColor}=this.context;
        return (
            <button onClick={()=>changeColor('red')}>点击设置父组件的context值</button>
        )
    }
}

```

### 路由传参

```javascript
// 路由中设置
<Router history={hashHistory}>
    <Route path="/PageA/:userId" component={PageA}></Route>
<Router>
//Link中写入要传参数
</Link to={`PageA/132456`} target="_blank"></Link>
//组件中接收参数
this.props.params.userId  //123456

```

### 事件与数据的双向绑定
```javascript
//事件的绑定
changeUserInfo(age) {  //点击事件
    this.setState({age: age});
}
childValueChange(event) { //子组件要调用的方法
    this.setState({age: event.target.value});
}
render() {
    return (
        <div>
            <p>age: {this.state.age}</p>
            <input type="button" value="提交" onClick={this.changeUserInfo.bind(this,99)}/>
            <Child childValueChange={this.childValueChange.bind(this)} />
        </div>
    )
}

//child组件中调用父组件方法
render(){
    return(
      <div>
        <p>子页面输入：<input type="text" onChange={this.props.childValueChange}/><p>
      </div>
    )
  }

```

### 组件refs

```javascript
/*Refs是访问到组件的DOM节点唯一可靠的方法
ref会自动销毁对自组件的引用
不要在render或者 render之前对refs进行调用
不要滥用refs*/
export default class BodyIndex extends React.Component {
	changeUserInfo(age) {
		this.setState({age: age});
		//第一种方式 原生方法
		// var mySubmitBotton  = document.getElementById('submitButton');
		// ReactDOM.findDOMNode(mySubmitBotton).style.color = 'red';

		//第二种方式
		console.log(this.refs.submitButton);
		this.refs.submitButton.style.color = 'red';
	};
	render() {
		return (
                    <div>
                      <p ref="submitButton" ></p>
                    </div>
		)
	}
}
```

### 循环渲染

```javascript
export default class ComponentHeader extends Component{
  render(){
    let arr=["contentA","contentB","contentC"];
    const compont={
        arr.map(function(name,index){
           return <div key={index}>{name}</div>
        })
        //key的作用是生成虚拟DOM时，需要使用key来进行标记,DOM更新时进行比较。
    }
    return (
      <header>
        {compont}
      </header>
    )
  }
}
```

### 表单的事件响应和bind复用
```javascript

getInitialState:function(){
    return{
        username:'',
        gender:'man',
        checked:true
    }
}
handleChange:function(name,event){
    var newState={};
    newState[name]=name=="checked"?event.target.checked:event.target.value;
    this.setState(newState);
    console.log(newState);
}
submitHandler:function(e){
   e.preventDefault();
   var is = this.state.checked?'是':'不是';
   var gender= this.state.gender == "man" ? "帅哥":"美女";
   alert(this.state.username+ is + gender +'.' );
}
render:function(){
   return (
    <form onSubmit={this.submitHandler}>
       <label htmlFor="username">情输入您的姓名：</label>
        <input type="text" name="username" onChange={this.handleChange.bind(this,"username")} value={this.state.username} id="username"  />
        <input  type="checkbox" value="是否" name="checked" onChange={this.handleChange.bind(this,"checked")} checked={this.state.checked}  />
       <select name="gender" onChange={this.handleChange.bind(this,"gender")} value={this.state.gender}>
            <option value="man">帅哥</option>
            <option value="woman">美女</option>
       </select>
       <button type="submit" >提交</button>
   </form>
  )
}
```

### css样式
```javascript

// 内联样式
export default class ComponentHeader extends React.Component {
    render() {
        const styleComponentHeader = {
            header: {
                backgroundColor: "#333333",
                color: "#FFFFFF",
                "padding-top": "15px",
                paddingBottom: "15px"
            },
            {/*注意驼峰写法
            class要改为className
            内联样式缺点是动画、伪类等不能使用*/}
            

            //还可以定义其他的样式
        };
        return (
            <header> style={styleComponentHeader.header} className="smallFontSize">
                <h1>这里是头部</h1>
            </header>
        )
    }
}

// 内联样式中的表达式
paddingBottom:(this.state.miniHeader)?"3px":"10px"  // 变量写括号里边

/*css模块化 
模块化优点：所有样式都是局部的，解决了命名冲突和全局污染问题
class名生成规则配置灵活、可以此来压缩class名
只需要引入组件的js就能搞定所有的js和css
footer.css 中*/
/*.miniFooter{
  background-color: #333333;
  color: #ffffff;
  padding-left: 20px;
  padding-top: 3px;
  padding-bottom: 3px;
}
*/
// 组件中调用
var footerCss  =  require("../../css/footer.css"); //引入css
export default class ComponentFooter extends React.Component{
  render(){
    console.log(footerCss); //输出一个对象
    return (
      <footer class={footerCss.miniFooter}></footer>
    )
  }
}



/*jsx样式与css的互转
在线转化工具 http://staxmanade.com/CssToReact/   将普通css样式转化为react css样式*/
```

## redux

#### 基本概念
- store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。
- Redux 提供`createStore`这个函数，用来生成 Store。
```javascript
import { createStore } from 'redux';
//createStore函数接受另一个函数作为参数，返回新生成的 Store 对象
const store = createStore(reducer);
```
####  `state` 
Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。
这种时点的数据集合，就叫做 State。

```javascript
import { createStore } from 'redux';
const store = createStore(fn);
//当前时刻的 State，可以通过store.getState()拿到。
const state = store.getState();
```

#### `Action` 
State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。
        Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置
        
```javascript
const action = {
  type: 'ADD_TODO',
  payload: 'Learn Redux'
};
```     

`Action Creator`  View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。  


```javascript

const ADD_TODO = '添加 TODO';
function addTodo(text) {
  return {
    type: ADD_TODO,
    text
  }
}

const action = addTodo('Learn Redux');

```

####  `store.dispatch()` 
:是 View 发出 Action 的唯一方法。

```javascript
import { createStore } from 'redux';
const store = createStore(reducer);

store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});
//效果同上
store.dispatch(addTodo('Learn Redux'));
```

####  `Reducer` 
:Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。
        Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。
        
```javascript

const defaultState = 0;
const reducer = (state = defaultState, action) => {
  switch (action.type) {
    case 'ADD':
      return state + action.payload;
    default: 
      return state;
  }
};

const state = reducer(1, {
  type: 'ADD',
  payload: 2
});
/*上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。

实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。
*/
import { createStore } from 'redux';
const store = createStore(reducer);

```   
    
####  `Reducer 的拆分`：
Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。
- Redux 提供了一个`combineReducers`方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。


```javascript

import { combineReducers } from 'redux';

const Reducers = combineReducers({
  chatLog,
  statusMessage,
  userName
})

export default Reducers;

//combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，
// 并将返回结果合并成一个大的 State 对象。


//你可以把所有子 Reducer 放在一个文件里面，然后统一引入。
import { combineReducers } from 'redux'
import * as reducers from './reducers'

const reducer = combineReducers(reducers)

```

###  connect()
- React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。


```javascript
import { connect } from 'react-redux'

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)

//mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。
const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}

//组件中访问todos    
// this.props.todos

//mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。
const mapStateToProps = (state, ownProps) => {
  return {
    active: ownProps.filter === state.visibilityFilter
  }
}
// 注意
/*使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。
connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。
*/


/*mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。
如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。
*/

import {addToDo,setFilter} from "./redux/action";
const VisibleTodoList = connect(
  mapStateToProps,
  {addToDo,setFilter}
)(TodoList)

//组件中调用 this.props.addToDo   this.props.setFilter 

```

### \<Provider\> 组件
- connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。
- 一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。
- React-Redux 提供Provider组件，可以让容器组件拿到state。

```javascript
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp);

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)


//它的原理是React组件的context属性
class Provider extends Component {
  getChildContext() {
    return {
      store: this.props.store
    };
  }
  render() {
    return this.props.children;
  }
}

Provider.childContextTypes = {
  store: React.PropTypes.object
}
```
### React-Router 路由库
```javascript
const Root = ({ store }) => (
  <Provider store={store}>
    <Router>
      <Route path="/" component={App} />
    </Router>
  </Provider>
);
```